---
title: Simulations
author: "Alessandro Gasparini"
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
    df_print: paged
    rows.print: 20
    theme: readable
classoption: a4paper, oneside
documentclass: article
fontsize: 11pt
csl: elsevier_titles.csl
bibliography: bib.bib
---

# Rationale

We want to show that Gaussian quadrature performs well even in situations where analytical formulae are available.

# Simulation strategies

## Simulation 1: analytical formulae against Gaussian quadrature

We run \(1000\) simulations under different scenarios, assuming a Weibull baseline hazard with shape parameter \(p = 1\) and scale parameter \(\lambda = 0.5\). We generate survival times \(s\) using the approach of Bender _et al_.[@bender_2005]; we generate censoring time \(c\) using the same approach, but without including covariates in the calculation. Then, the observed time will be defined as \(t = \text{min}(s, c)\) and the event indicator variable as \(d = I(s \le c)\).

We compare the use of analytical formulae against Gaussian quadrature varying:

1- combinations of number of individuals per cluster (\(25\), \(50\), \(100\), \(500\), \(1000\)) and number of clusters (\(15\), \(30\), \(100\), \(200\));

2- treatment effect: positive \(0.5\), negative \(-0.5\), null \(0.0\);

3- variance of the frailty term: small \(0.25\), medium \(0.50\), large \(0.75\);

4- number of quadrature knots: \(35\), \(75\), \(105\).

## Simulation 2: log-normal frailty

We run \(1000\) simulations under different scenarios, assuming a Weibull baseline hazard with shape parameter \(p = 1.5\) and scale parameter \(\lambda = 3.0\). We generate survival times as in simulation n. \(1\), varying:

1- combinations of number of individuals per cluster (\(25\), \(50\), \(100\), \(500\), \(1000\)) and number of clusters (\(15\), \(30\), \(100\), \(200\));

2- treatment effect: positive \(0.5\), negative \(-0.5\), null \(0.0\);

3- variance of the frailty term: small \(0.25\), medium \(0.50\), large \(0.75\);

4- number of quadrature knots: \(35\), \(75\), \(105\).

## Reporting

We report on:

1- average estimate of interest \(\bar{\hat{\beta}} = 1 / B \times \sum_{i = 1}^B \hat{\beta}_i\), and median estimate of interest;

2- average within-simulation standard error [SE] \(\sum_{i = 1} ^ B \text{SE}(\hat{\beta}_i) / B\) and median within-simulation standard error;

3- empirical SE \(\sqrt{\left[ 1 / (B - 1) \right] \sum_{i = 1} ^ B (\hat{\beta}_i - \bar{\hat{\beta}}) ^ 2}\);

4- bias \(\delta = \bar{\hat{\beta}} - \beta\);

5- mean square error \((\bar{\hat{\beta}} - \beta) ^ 2 + \text{SE}(\hat{\beta}) ^ 2\);

6- coverage probability, i.e. the proportion of times the \(100(1 - \alpha)\%\) confidence interval \(\hat{\beta}_i \pm Z_{1-\alpha/2} \times \text{SE}(\hat{\beta}_i)\) include \(\beta\), \(\forall i = 1, \dots, B\).

# Statistical methods

## Weibull parametric survival model

We use a Weibull parametric survival model with a Gamma frailty term via the proportional hazards parametrisation:

\[
h(t_i) = h_0(t) g(X_i),
\]

with \(g(X_i)\) non-negative function of the covariates, usually \(g(X_i) = \exp(X_i \beta)\).

In our setting:

\[
h_0(t) = p t ^ {p - 1},
\]

the survivor function is

\[
S(t) = \exp(-\lambda_i t_i ^ p)
\]

with parametrisation

\[
\lambda_i = \exp(X_i \beta).
\]

Hence, the Weibull parametric survival model has hazard function:

\[
h(t) = p \lambda t ^ {p - 1}.
\]

The individual contribution to the likelihood is:

\[
L_i = h(t_i) ^ d_i S(t_i),
\]

where \(d_i\) is the event indicator variable.

The overall likelihood is the product of the individual contributions:

\[
L = \prod_{i = 1} ^ n L_i.
\]

Taking the natural logarithm of the likelihood for ease of computation:

\[
\begin{aligned}
\log L &= \sum_{i = 1} ^ n \left[ d_i \log f_i(t_i) + (1 - d_i) \log S_i(t_i) \right] = \\
       &= \sum_{i = 1} ^ n \left[ d_i \log h_i(t_i) + \log S_i(t_i) \right]
\end{aligned}
\]

## Frailty models

A frailty model is a survival model with unobservable heterogeneity. At the observation level, the frailty is introduced as an unobservable multiplicative effect \(\alpha\) on the hazard function:

\[
h(t | \alpha) = \alpha h(t)
\]

The survivor function given the frailty can be written as:

\[
S(t | \alpha) = \cdots = S(t) ^ \alpha
\]

As \(\alpha\) is unobservable, it must be integrated out of \(S(t | \alpha)\) to obtain the unconditional survivor function:

\[
S_{\theta}(t) = \int S(t|\alpha)g(\alpha) \ d\alpha = \int \left[ S(t) \right] ^ \alpha g(\alpha) \ d\alpha
\]

Given the unconditional survivor function, we can obtain the unconditional hazard and density (and consequently the likelihood) in the usual way:

\[
f_{\theta}(t) = - \frac{d}{dt} S_{\theta}(t) 
\]

\[
h_{\theta}(t) = \frac{f_{\theta}(t)}{S_{\theta}(t)}
\]

A common choice for the frailty distribution \(g(\alpha)\) is the Gamma distribution. In particular, for mathematical tractability, a \(Gamma(1/\theta, \theta)\) distribution is often used. 

A \(Gamma(a, b)\) distribution has probability density function 

\[
g(x) = \frac{x ^ {a - 1} \exp(-x / b)}{\Gamma(a) b ^ a}.
\]

Using the aforementioned \(Gamma(1 / \theta, \theta)\) distribution, the survivor function conditional on the frailty can be written as:

\[
S_\theta(t) = \left[ 1 - \theta \log \left\{ S(t) \right\} \right] ^ {-1 / \theta}
\]

Thus, it follows that the log-likelihood can be written as:

\[
\log L = \sum_{i = 1} ^ n \left[ d_i \log h_i(t_i) - (\theta ^ {-1} + d_i) \log \left\{ 1 - \theta \log S_i(t_i) \right\} \right]
\]

## Shared-frailty models

A generalisation of frailty models is the shared-frailty model, where the frailty is assumed to be group-specific. For observation \(j\) from the \(i\)-th group, the hazard is:

\[
h_{ij}(t | \alpha_i) = \alpha_i h_{ij}(t),
\]

where \(h_{ij}(t) = h(t | X_{ij})\), i.e. the individual hazard given covariates \(X_{ij}\).

In a shared frailty model, the frailty is common to a group of observations. Thus, to form an unconditional likelihood, the frailties must be integrated out at the group level. 

The contribution to the likelihood for the \(ij\)-th individual, given \(\alpha_i\):

\[
L_{ij}(\alpha_i) = S_{ij}(t_{ij}) ^ {\alpha_i} \left[ \alpha_i h_{ij}(t_{ij}) \right] ^ {d_{ij}}
\]

Define \(D_i = \sum_j d_{ij}\) as the number of failures in the \(i\)-th group. The log-likelihood contribution for the \(i\)-th group is:

\[
L_i(\alpha_i) = \alpha_i ^ {D_i} \prod_{j = 1} ^ {n_i} \left[ S_{ij}(t_{ij}) ^ {\alpha_i} \left( h_{ij}(t_{ij}) \right) ^ {d_{ij}} \right]
\]

Integrating out \(\alpha_i\), we can obtain the unconditional contribution to the likelihood:

\[
L_i = \int L_i(\alpha_i) g(\alpha_i) \ d \alpha_i
\]

If the frailty is Gamma-distributed, it is possible to derive an analytical form for the group contribution to the likelihood:

\[
\begin{aligned}
\log L_i =& \sum_{j = 1} ^ {n_i} d_{ij} \log h_{ij}(t_{ij}) - (1 / \theta + D_i) \log \left\{ 1 - \theta \sum_{j = 1} ^ {n_i} \log S_{ij}(t_{ij}) \right\} + \\
          &D_i \log \theta + \log \Gamma(1 / \theta + D_i) - \log \Gamma(1 / \theta),
\end{aligned}
\]

with the overall log-likelihood being, for $N$ clusters,

\[
\log L = \sum_{i = 1} ^ {N} \log L_i. 
\]

## Gaussian quadrature

In numerical analysis, a quadrature rule is an approximation of the definite integral of a function, usually via a weighted sum of function values at specified points within the domain of integration. An \(n\)-point Gaussian quadrature rule is a quadrature rule where the approximation is exact for polynomials of degree \(2n - 1\) or less.
A generic \(n\)-point Gaussian quadrature rule for approximating a function \(f(x)\) over its domain \(D\) can be stated as:

\[
\int_D f(x) \ dx \approx \sum_{i = 1} ^ n w_i f(x_i)
\]

If the integrated function can be written as \(f(x) = w(x) g(x)\), the quadrature rule becomes

\[
\int_D f(x) \ dx = \int_D w(x)g(x) \ dx \approx \sum_{i = 1} ^ n w_i g(x_i)
\]

A common weight function \(w(x) = e ^ {-x ^ 2}\) yields a so-called Gauss-Hermite quadrature rule. Further details in @liu_1994.

In the context of parametric survival models with frailty terms, the term we would wish to approximate is the frailty density in the likelihood function. The cluster-specific unconditional likelihood, for Gamma-distributed frailties \((\alpha_i)\), is:

\[
\begin{aligned}
L_i &= \int_0 ^ {+ \infty} L_i(\alpha_i) g(\alpha_i) \ d \alpha_i \\
    &= \int_0 ^ {+ \infty} \alpha_i ^ {D_i} \prod_{j = 1} ^ {n_i} \left[ S_{ij}(t_{ij}) ^ {\alpha_i} h_{ij}(t_{ij}) ^ {d_{ij}} \right] \frac{\alpha ^ {1 / \theta - 1} \exp(- \alpha / \theta)}{\Gamma(1 / \theta) \theta ^ {1 / \theta}} \ d \alpha_i = \\
    &= \int_0 ^ {+ \infty} \alpha_i ^ {D_i} \prod_{j = 1} ^ {n_i} \left[ \left( \exp \left( -t_{ij} ^ p \exp \left( p \lambda t_{ij} ^ {p - 1} \exp \left( X_{ij} \beta \right) \right) \right) \right) ^ {\alpha_i} \left( p \lambda t_{ij} ^ {p - 1} \exp \left( X_{ij} \beta \right) \right) ^ {d_{ij}} \right] \times \\
    & \qquad \times \frac{\alpha_i ^ {1 / \theta - 1} \exp(- \alpha_i / \theta)}{\Gamma(1 / \theta) \theta ^ {1 / \theta}} \ d \alpha_i
\end{aligned}
\]

The integral is over the \(0, \  +\infty\) domain, hence we need to apply the so-called Gauss-Laguerre quadrature rule. The Gauss-Laguerre quadrature rule is used to approximate integrals of the kind

\[
\int_0 ^ {+\infty} x ^ \alpha e ^ {-x} f(x) \ dx \approx \sum_{i = 1} ^ n w_i f(x_i),
\]

for some real number \(\alpha > -1\), to handle singularities at \(x = 0\). We will assume \(\alpha = 0\). In our more general function, where it is not straightforward to extract the weight term (i.e. \(e ^ {-\alpha}\)), we apply the following transformation:

\[
\int_0 ^ {+\infty} f(x) \ dx = \int_0 ^ {+\infty} e ^ x e ^ {-x} f(x) \ dx = \int_0 ^ {+\infty} e ^ {-x} g(x) \ dx \approx \sum_{i = 1} ^ n w_i g(x_i)
\]

This approach is analytically valid, but it may not always be numerically stable.

## Parametric survival model with a random treatment effect

In addition to the abovementioned model, we will estimate a Weibull parametric survival model with a Normal-distributed random effect:

\[
h_{ij} = \lambda p t ^ {p - 1} \exp((b_{1i} + \beta_1) X_{1ij}),
\]

with \(i\) identifying the cluster-level and \(j\) identifying the individual-level. This model requires integrating over the random effects to estimate the model parameters. The \(i\)-th cluster contribution to the likelihood is:

\[
\begin{aligned}
L_i &= \int_{-\infty}^{+\infty} \left[ \prod_{j = 1} ^ {n_i} h_{ij}(t_{ij}) ^ {d_{ij}} S_{ij}(t_{ij}) \right] p(b_i) \ db_i = \\
    &= \int_{-\infty}^{+\infty} \left[ \prod_{j = 1} ^ {n_i} \left( \lambda p t_{ij} ^ {p - 1} \exp((b_{1i} + \beta_1) X_{1ij}) \right) ^ {d_{ij}} \left( \exp(-\lambda t_{ij} ^ p \exp((b_{1i} + \beta_1) X_{1ij}) \right) \right] \times \\
    & \qquad \times \frac{1}{\sqrt{2 \sigma ^ 2 \pi}} \ \exp \left( -\frac{b_i ^ 2}{2 \sigma ^ 2} \right) \ db_i = \\
    &= \frac{1}{\sqrt{2 \sigma ^ 2 \pi}} \int_{-\infty}^{+\infty} \left[ \prod_{j = 1} ^ {n_i} \left( \lambda p t_{ij} ^ {p - 1} \exp((b_{1i} + \beta_1) X_{1ij}) \right) ^ {d_{ij}} \left( \exp(-\lambda t_{ij} ^ p \exp((b_{1i} + \beta_1) X_{1ij}) \right) \right] \times \\
    & \qquad \times \exp \left( -\frac{b_i ^ 2}{2 \sigma ^ 2} \right) \ db_i \\
\end{aligned}
\]

# Results

```{r, include = FALSE}
# Setting knitr options:
if (!requireNamespace("knitr")) install.packages("knitr")
knitr::opts_chunk$set(tidy = TRUE, echo = FALSE, warning = FALSE, dpi = 300, fig.retina = 2)

# Loading packages and data:

if (!requireNamespace("pacman")) install.packages("pacman")
pacman::p_load("dplyr", "tidyr", "ggplot2", "ggthemes", "stringr")
s_an_vs_gq <- lapply(list.files(path = "Results/", pattern = "an_vs_gq", full.names = T), readRDS) %>% 
  bind_rows()
s_normal_gq <- lapply(list.files(path = "Results/", pattern = "normal_gq", full.names = T), readRDS) %>% 
  bind_rows()
```

## Analytical formulae against Gaussian quadrature

```{r}
# Process the results and compute statistics of interest:
s_an_vs_gq_summary <- s_an_vs_gq %>% 
  mutate(AF_trt_bias = AF_trt - treatment_effect,
         GQ_trt_bias = GQ_trt - treatment_effect,
         AF_theta_bias = AF_theta - log(frailty_theta),
         GQ_theta_bias = GQ_theta - log(frailty_theta),
         AF_lambda_bias = AF_lambda - log(lambda),
         GQ_lambda_bias = GQ_lambda - log(lambda),
         AF_p_bias = AF_p - log(p),
         GQ_p_bias = GQ_p - log(p),
         AF_trt_covp = ifelse(treatment_effect >= (AF_trt - AF_trt_se * qnorm(1 - 0.05/2)) & treatment_effect <= (AF_trt + AF_trt_se * qnorm(1 - 0.05/2)), 1, 0),
         GQ_trt_covp = ifelse(treatment_effect >= (GQ_trt - GQ_trt_se * qnorm(1 - 0.05/2)) & treatment_effect <= (GQ_trt + GQ_trt_se * qnorm(1 - 0.05/2)), 1, 0),
         AF_theta_covp = ifelse(log(frailty_theta) >= (AF_theta - AF_theta_se * qnorm(1 - 0.05/2)) & log(frailty_theta) <= (AF_theta + AF_theta_se * qnorm(1 - 0.05/2)), 1, 0),
         GQ_theta_covp = ifelse(log(frailty_theta) >= (GQ_theta - GQ_theta_se * qnorm(1 - 0.05/2)) & log(frailty_theta) <= (GQ_theta + GQ_theta_se * qnorm(1 - 0.05/2)), 1, 0),
         AF_lambda_covp = ifelse(log(lambda) >= (AF_lambda - AF_lambda_se * qnorm(1 - 0.05/2)) & log(lambda) <= (AF_lambda + AF_lambda_se * qnorm(1 - 0.05/2)), 1, 0),
         GQ_lambda_covp = ifelse(log(lambda) >= (GQ_lambda - GQ_lambda_se * qnorm(1 - 0.05/2)) & log(lambda) <= (GQ_lambda + GQ_lambda_se * qnorm(1 - 0.05/2)), 1, 0),
         AF_p_covp = ifelse(log(p) >= (AF_p - AF_p_se * qnorm(1 - 0.05/2)) & log(p) <= (AF_p + AF_p_se * qnorm(1 - 0.05/2)), 1, 0),
         GQ_p_covp = ifelse(log(p) >= (GQ_p - GQ_p_se * qnorm(1 - 0.05/2)) & log(p) <= (GQ_p + GQ_p_se * qnorm(1 - 0.05/2)), 1, 0)) %>% 
  group_by(n_individuals, n_clusters, frailty_theta, treatment_effect, ngl, lambda, p) %>% 
  summarise(AF_convp = mean(AF_convergence == 0),
            GQ_convp = mean(GQ_convergence == 0),
            AF_convn = sum(AF_convergence == 0),
            GQ_convn = sum(GQ_convergence == 0),
            AF_trt_mean = mean(AF_trt, na.rm = TRUE),
            GQ_trt_mean = mean(GQ_trt, na.rm = TRUE),
            AF_trt_median = median(AF_trt, na.rm = TRUE),
            GQ_trt_median = median(GQ_trt, na.rm = TRUE),
            AF_trt_se_mean = mean(AF_trt_se, na.rm = TRUE),
            GQ_trt_se_mean = mean(GQ_trt_se, na.rm = TRUE),
            AF_trt_se_median = median(AF_trt_se, na.rm = TRUE),
            GQ_trt_se_median = median(GQ_trt_se, na.rm = TRUE),
            AF_trt_empse = sqrt((1 / (n() - 1)) * sum((AF_trt - AF_trt_mean) ^ 2, na.rm = TRUE)),
            GQ_trt_empse = sqrt((1 / (n() - 1)) * sum((GQ_trt - GQ_trt_mean) ^ 2, na.rm = TRUE)),
            AF_trt_bias = mean(AF_trt_bias, na.rm = TRUE),
            GQ_trt_bias = mean(GQ_trt_bias, na.rm = TRUE),
            AF_trt_covp = mean(AF_trt_covp, na.rm = TRUE),
            GQ_trt_covp = mean(GQ_trt_covp, na.rm = TRUE),
            AF_theta_mean = mean(AF_theta, na.rm = TRUE),
            GQ_theta_mean = mean(GQ_theta, na.rm = TRUE),
            AF_theta_median = median(AF_theta, na.rm = TRUE),
            GQ_theta_median = median(GQ_theta, na.rm = TRUE),
            AF_theta_se_mean = mean(AF_theta_se, na.rm = TRUE),
            GQ_theta_se_mean = mean(GQ_theta_se, na.rm = TRUE),
            AF_theta_se_median = median(AF_theta_se, na.rm = TRUE),
            GQ_theta_se_median = median(GQ_theta_se, na.rm = TRUE),
            AF_theta_empse = sqrt((1 / (n() - 1)) * sum((AF_theta - AF_theta_mean) ^ 2, na.rm = TRUE)),
            GQ_theta_empse = sqrt((1 / (n() - 1)) * sum((GQ_theta - GQ_theta_mean) ^ 2, na.rm = TRUE)),
            AF_theta_bias = mean(AF_theta_bias, na.rm = TRUE),
            GQ_theta_bias = mean(GQ_theta_bias, na.rm = TRUE),
            AF_theta_covp = mean(AF_theta_covp, na.rm = TRUE),
            GQ_theta_covp = mean(GQ_theta_covp, na.rm = TRUE),
            AF_lambda_mean = mean(AF_lambda, na.rm = TRUE),
            GQ_lambda_mean = mean(GQ_lambda, na.rm = TRUE),
            AF_lambda_median = median(AF_lambda, na.rm = TRUE),
            GQ_lambda_median = median(GQ_lambda, na.rm = TRUE),
            AF_lambda_se_mean = mean(AF_lambda_se, na.rm = TRUE),
            GQ_lambda_se_mean = mean(GQ_lambda_se, na.rm = TRUE),
            AF_lambda_se_median = median(AF_lambda_se, na.rm = TRUE),
            GQ_lambda_se_median = median(GQ_lambda_se, na.rm = TRUE),
            AF_lambda_empse = sqrt((1 / (n() - 1)) * sum((AF_lambda - AF_lambda_mean) ^ 2, na.rm = TRUE)),
            GQ_lambda_empse = sqrt((1 / (n() - 1)) * sum((GQ_lambda - GQ_lambda_mean) ^ 2, na.rm = TRUE)),
            AF_lambda_bias = mean(AF_lambda_bias, na.rm = TRUE),
            GQ_lambda_bias = mean(GQ_lambda_bias, na.rm = TRUE),
            AF_lambda_covp = mean(AF_lambda_covp, na.rm = TRUE),
            GQ_lambda_covp = mean(GQ_lambda_covp, na.rm = TRUE),
            AF_p_mean = mean(AF_p, na.rm = TRUE),
            GQ_p_mean = mean(GQ_p, na.rm = TRUE),
            AF_p_median = median(AF_p, na.rm = TRUE),
            GQ_p_median = median(GQ_p, na.rm = TRUE),
            AF_p_se_mean = mean(AF_p_se, na.rm = TRUE),
            GQ_p_se_mean = mean(GQ_p_se, na.rm = TRUE),
            AF_p_se_median = median(AF_p_se, na.rm = TRUE),
            GQ_p_se_median = median(GQ_p_se, na.rm = TRUE),
            AF_p_empse = sqrt((1 / (n() - 1)) * sum((AF_p - AF_p_mean) ^ 2, na.rm = TRUE)),
            GQ_p_empse = sqrt((1 / (n() - 1)) * sum((GQ_p - GQ_p_mean) ^ 2, na.rm = TRUE)),
            AF_p_bias = mean(AF_p_bias, na.rm = TRUE),
            GQ_p_bias = mean(GQ_p_bias, na.rm = TRUE),
            AF_p_covp = mean(AF_p_covp, na.rm = TRUE),
            GQ_p_covp = mean(GQ_p_covp, na.rm = TRUE)) %>% 
  mutate(AF_trt_mse = AF_trt_bias ^ 2 + AF_trt_empse ^ 2,
         GQ_trt_mse = GQ_trt_bias ^ 2 + GQ_trt_empse ^ 2,
         AF_theta_mse = AF_theta_bias ^ 2 + AF_theta_empse ^ 2,
         GQ_theta_mse = GQ_theta_bias ^ 2 + GQ_theta_empse ^ 2,
         AF_lambda_mse = AF_lambda_bias ^ 2 + AF_lambda_empse ^ 2,
         GQ_lambda_mse = GQ_lambda_bias ^ 2 + GQ_lambda_empse ^ 2,
         AF_p_mse = AF_p_bias ^ 2 + AF_p_empse ^ 2,
         GQ_p_mse = GQ_p_bias ^ 2 + GQ_p_empse ^ 2)

saveRDS(s_an_vs_gq_summary, "r_AF_vs_GQ/s_an_vs_gq_summary.RDS")
```

<center>
<button type="button" onClick="document.getElementById('resIF').src='http://ag475.shinyapps.io/shinyapp'; this.parentNode.style.display = 'none';">Load results...</button>
</center>

<iframe id="resIF" style="border: none; width: 95%; height: 700px"></iframe>

### Convergence

Number of simulations converging:

```{r}
# By n_individuals:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(n_individuals), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  theme(legend.position = c(1, 0), legend.justification = c(1, 0), legend.background = element_blank()) + 
  labs(x = "N. of individuals per cluster", y = "N. of simulations converging", color = "")

# By n_clusters:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(n_clusters), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "N. of clusters", y = "N. of simulations converging", color = "")

# By treatment_effect:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(treatment_effect), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "Treatment effect", y = "N. of simulations converging", color = "")

# By frailty_theta:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(frailty_theta), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  theme(legend.position = c(1, 0), legend.justification = c(1, 0), legend.background = element_blank()) + 
  labs(x = "Frailty variance", y = "N. of simulations converging", color = "")

# By ngl:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(ngl), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "Gauss-Laguerre knots", y = "N. of simulations converging", color = "")
```

Proportion of simulations converging:

```{r}
# By n_individuals:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(n_individuals), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::percent) +
  theme_bw() + 
  theme(legend.position = c(1, 0), legend.justification = c(1, 0), legend.background = element_blank()) + 
  labs(x = "N. of individuals per cluster", y = "P. of simulations converging", color = "")

# By n_clusters:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(n_clusters), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::percent) +
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "N. of clusters", y = "P. of simulations converging", color = "")

# By treatment_effect:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(treatment_effect), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::percent) +
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "Treatment effect", y = "P. of simulations converging", color = "")

# By frailty_theta:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(frailty_theta), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::percent) +
  theme_bw() + 
  theme(legend.position = c(1, 0), legend.justification = c(1, 0), legend.background = element_blank()) + 
  labs(x = "Frailty variance", y = "P. of simulations converging", color = "")

# By ngl:
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(ngl), y = value, color = method)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::percent) +
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "Gauss-Laguerre knots", y = "P. of simulations converging", color = "")
```

### Estimated values

```{r}
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^mean", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "theta", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = method, y = value, color = name)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "", y = "Estimates (Mean)", color = "")
```

```{r}
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^median", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "theta", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = method, y = value, color = name)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "", y = "Estimates (Median)", color = "")
```

### Bias

```{r}
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^bias", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "theta", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = method, y = value, color = name)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  theme(legend.position = c(0, 1), legend.justification = c(0, 1), legend.background = element_blank()) + 
  labs(x = "", y = "Bias", color = "")
```

### Coverage probability

```{r}
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^covp", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "theta", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = method, y = value, color = name)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::percent) + 
  theme_bw() + 
  theme(legend.position = c(0, 0), legend.justification = c(0, 0), legend.background = element_blank()) + 
  labs(x = "", y = "Coverage probability", color = "")
```

### Standard errors

Average standard errors:

```{r}
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^se_mean", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "theta", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = method, y = value, color = name)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) + 
  theme_bw() + 
  theme(legend.position = c(0, 1), legend.justification = c(0, 1), legend.background = element_blank()) + 
  labs(x = "", y = "SE (Mean)", color = "")
```

Median standard errors:

```{r}
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^se_median", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "theta", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = method, y = value, color = name)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) + 
  theme_bw() + 
  theme(legend.position = c(0, 1), legend.justification = c(0, 1), legend.background = element_blank()) + 
  labs(x = "", y = "SE (Median)", color = "")
```

Empirical standard errors:

```{r}
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^empse", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "theta", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = method, y = value, color = name)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) + 
  theme_bw() + 
  theme(legend.position = c(0, 1), legend.justification = c(0, 1), legend.background = element_blank()) + 
  labs(x = "", y = "Empirical SE", color = "")
```

### Mean square error

```{r}
s_an_vs_gq_summary %>%
  gather(key = key, value = value, 8:75) %>%
  mutate(method = str_sub(key, 1, 2),
         par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^mse", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "theta", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = method, y = value, color = name)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  scale_y_continuous(labels = scales::comma) + 
  theme_bw() + 
  theme(legend.position = c(0, 1), legend.justification = c(0, 1), legend.background = element_blank()) + 
  labs(x = "", y = "MSE", color = "")
```

## Gaussian quadrature with Normal frailty

```{r}
# Process the results and compute statistics of interest:
s_normal_gq_summary <- s_normal_gq %>% 
  mutate(GQ_trt_bias = GQ_trt - treatment_effect,
         GQ_sigma_bias = GQ_sigma - log(frailty_sigma),
         GQ_lambda_bias = GQ_lambda - log(lambda),
         GQ_p_bias = GQ_p - log(p),
         GQ_trt_covp = ifelse(treatment_effect >= (GQ_trt - GQ_trt_se * qnorm(1 - 0.05/2)) & treatment_effect <= (GQ_trt + GQ_trt_se * qnorm(1 - 0.05/2)), 1, 0),
         GQ_sigma_covp = ifelse(log(frailty_sigma) >= (GQ_sigma - GQ_sigma_se * qnorm(1 - 0.05/2)) & log(frailty_sigma) <= (GQ_sigma + GQ_sigma_se * qnorm(1 - 0.05/2)), 1, 0),
         GQ_lambda_covp = ifelse(log(lambda) >= (GQ_lambda - GQ_lambda_se * qnorm(1 - 0.05/2)) & log(lambda) <= (GQ_lambda + GQ_lambda_se * qnorm(1 - 0.05/2)), 1, 0),
         GQ_p_covp = ifelse(log(p) >= (GQ_p - GQ_p_se * qnorm(1 - 0.05/2)) & log(p) <= (GQ_p + GQ_p_se * qnorm(1 - 0.05/2)), 1, 0)) %>% 
  group_by(n_individuals, n_clusters, frailty_sigma, treatment_effect, ngh, lambda, p) %>% 
  summarise(GQ_convp = mean(GQ_convergence == 0),
            GQ_convn = sum(GQ_convergence == 0),
            GQ_trt_mean = mean(GQ_trt, na.rm = TRUE),
            GQ_trt_median = median(GQ_trt, na.rm = TRUE),
            GQ_trt_se_mean = mean(GQ_trt_se, na.rm = TRUE),
            GQ_trt_se_median = median(GQ_trt_se, na.rm = TRUE),
            GQ_trt_empse = sqrt((1 / (n() - 1)) * sum((GQ_trt - GQ_trt_mean) ^ 2, na.rm = TRUE)),
            GQ_trt_bias = mean(GQ_trt_bias, na.rm = TRUE),
            GQ_trt_covp = mean(GQ_trt_covp, na.rm = TRUE),
            GQ_sigma_mean = mean(GQ_sigma, na.rm = TRUE),
            GQ_sigma_median = median(GQ_sigma, na.rm = TRUE),
            GQ_sigma_se_mean = mean(GQ_sigma_se, na.rm = TRUE),
            GQ_sigma_se_median = median(GQ_sigma_se, na.rm = TRUE),
            GQ_sigma_empse = sqrt((1 / (n() - 1)) * sum((GQ_sigma - GQ_sigma_mean) ^ 2, na.rm = TRUE)),
            GQ_sigma_bias = mean(GQ_sigma_bias, na.rm = TRUE),
            GQ_sigma_covp = mean(GQ_sigma_covp, na.rm = TRUE),
            GQ_lambda_mean = mean(GQ_lambda, na.rm = TRUE),
            GQ_lambda_median = median(GQ_lambda, na.rm = TRUE),
            GQ_lambda_se_mean = mean(GQ_lambda_se, na.rm = TRUE),
            GQ_lambda_se_median = median(GQ_lambda_se, na.rm = TRUE),
            GQ_lambda_empse = sqrt((1 / (n() - 1)) * sum((GQ_lambda - GQ_lambda_mean) ^ 2, na.rm = TRUE)),
            GQ_lambda_bias = mean(GQ_lambda_bias, na.rm = TRUE),
            GQ_lambda_covp = mean(GQ_lambda_covp, na.rm = TRUE),
            GQ_p_mean = mean(GQ_p, na.rm = TRUE),
            GQ_p_median = median(GQ_p, na.rm = TRUE),
            GQ_p_se_mean = mean(GQ_p_se, na.rm = TRUE),
            GQ_p_se_median = median(GQ_p_se, na.rm = TRUE),
            GQ_p_empse = sqrt((1 / (n() - 1)) * sum((GQ_p - GQ_p_mean) ^ 2, na.rm = TRUE)),
            GQ_p_bias = mean(GQ_p_bias, na.rm = TRUE),
            GQ_p_covp = mean(GQ_p_covp, na.rm = TRUE)) %>% 
  mutate(GQ_trt_mse = GQ_trt_bias ^ 2 + GQ_trt_empse ^ 2,
         GQ_sigma_mse = GQ_sigma_bias ^ 2 + GQ_sigma_empse ^ 2,
         GQ_lambda_mse = GQ_lambda_bias ^ 2 + GQ_lambda_empse ^ 2,
         GQ_p_mse = GQ_p_bias ^ 2 + GQ_p_empse ^ 2)

saveRDS(s_normal_gq_summary, "r_normal_GQ/s_normal_gq_summary.RDS")
```

### Convergence

Number of simulations converging:

```{r}
# By n_individuals:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(n_individuals), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "N. of individuals per cluster", y = "N. of simulations converging")

# By n_clusters:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(n_clusters), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "N. of clusters", y = "N. of simulations converging")

# By treatment_effect:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(treatment_effect), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "Treatment effect", y = "N. of simulations converging")

# By frailty_sigma:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(frailty_sigma), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "Frailty variance", y = "N. of simulations converging")

# By ngh:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convn", stat)) %>%
  ggplot(aes(x = factor(ngh), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "Gauss-Hermite knots", y = "N. of simulations converging")
```

Proportion of simulations converging:

```{r}
# By n_individuals:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(n_individuals), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "N. of individuals per cluster", y = "P. of simulations converging")

# By n_clusters:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(n_clusters), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "N. of clusters", y = "P. of simulations converging")

# By treatment_effect:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(treatment_effect), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "Treatment effect", y = "P. of simulations converging")

# By frailty_sigma:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(frailty_sigma), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "Frailty variance", y = "P. of simulations converging")

# By ngh:
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^convp", stat)) %>%
  ggplot(aes(x = factor(ngh), y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::comma) +
  theme_bw() + 
  labs(x = "Gauss-Hermite knots", y = "P. of simulations converging")
```

### Estimated values

Average estimates:

```{r}
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat),
         scenario = factor(paste0("Fr. variance: ", frailty_sigma, "; tr. effect: ", treatment_effect))) %>% 
  filter(grepl("^mean", stat)) %>%
  mutate(name = factor(name, levels = c("trt", "sigma", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = name, y = value, color = scenario)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  labs(x = "", y = "Estimates (Mean)", color = "Sim. scenario")
```

Median estimates:

```{r}
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat),
         scenario = factor(paste0("Fr. variance: ", frailty_sigma, "; tr. effect: ", treatment_effect))) %>% 
  filter(grepl("^median", stat)) %>%
  mutate(name = factor(name, levels = c("trt", "sigma", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = name, y = value, color = scenario)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  labs(x = "", y = "Estimates (Median)", color = "Sim. scenario")
```

### Bias

```{r}
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^bias", stat)) %>%
  mutate(name = factor(name, levels = c("trt", "sigma", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = name, y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  labs(x = "", y = "Bias")
```

### Coverage probability

```{r}
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat)) %>% 
  filter(grepl("^covp", stat)) %>% 
  mutate(name = factor(name, levels = c("trt", "sigma", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = name, y = value)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_y_continuous(labels = scales::percent) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  labs(x = "", y = "Coverage probability")
```

### Standard errors

Average standard errors:

```{r}
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat),
         scenario = factor(paste0("Fr. variance: ", frailty_sigma, "; tr. effect: ", treatment_effect))) %>% 
  filter(grepl("^se_mean", stat)) %>%
  mutate(name = factor(name, levels = c("trt", "sigma", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = name, y = value, color = scenario)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  labs(x = "", y = "SE (Mean)", color = "Sim. scenario")
```

Median standard errors:

```{r}
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat),
         scenario = factor(paste0("Fr. variance: ", frailty_sigma, "; tr. effect: ", treatment_effect))) %>% 
  filter(grepl("^se_median", stat)) %>%
  mutate(name = factor(name, levels = c("trt", "sigma", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = name, y = value, color = scenario)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  labs(x = "", y = "SE (Median)", color = "Sim. scenario")
```

Empirical standard errors:

```{r}
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat),
         scenario = factor(paste0("Fr. variance: ", frailty_sigma, "; tr. effect: ", treatment_effect))) %>% 
  filter(grepl("^empse", stat)) %>%
  mutate(name = factor(name, levels = c("trt", "sigma", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = name, y = value, color = scenario)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  labs(x = "", y = "Empirical SE", color = "Sim. scenario")
```

### Mean square error

```{r}
s_normal_gq_summary %>%
  gather(key = key, value = value, 8:41) %>%
  mutate(par = str_sub(key, 4, str_length(key))) %>%
  separate(par, c("name", "stat"), sep = "_", extra = "merge") %>%
  mutate(stat = ifelse(is.na(stat), name, stat),
         scenario = factor(paste0("Fr. variance: ", frailty_sigma, "; tr. effect: ", treatment_effect))) %>% 
  filter(grepl("^mse", stat)) %>%
  mutate(name = factor(name, levels = c("trt", "sigma", "lambda", "p"), labels = c("Treatment effect", "Frailty variance", "Lambda", "P"))) %>% 
  ggplot(aes(x = name, y = value, color = scenario)) +
  geom_jitter(height = 0) + 
  geom_boxplot(alpha = 3/4) + 
  scale_color_brewer(type = "qual", palette = "Set1") + 
  theme_bw() + 
  labs(x = "", y = "MSE", color = "Sim. scenario")
```

## Application to catheter data



# References
